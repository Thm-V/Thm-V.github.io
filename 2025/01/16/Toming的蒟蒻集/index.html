<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言存放了一波自己XCPC生涯的板子，会带到比赛场上霍霍的那种，包括遗忘的，新学的。。。">
<meta property="og:type" content="article">
<meta property="og:title" content="Toming的蒟蒻集">
<meta property="og:url" content="http://example.com/2025/01/16/Toming%E7%9A%84%E8%92%9F%E8%92%BB%E9%9B%86/index.html">
<meta property="og:site_name" content="TOMING&#39;s BLOG">
<meta property="og:description" content="前言存放了一波自己XCPC生涯的板子，会带到比赛场上霍霍的那种，包括遗忘的，新学的。。。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-16T14:20:55.000Z">
<meta property="article:modified_time" content="2025-01-18T15:05:31.301Z">
<meta property="article:author" content="Toming">
<meta property="article:tag" content="XCPC&#x2F;ACM - 学习笔记">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/01/16/Toming%E7%9A%84%E8%92%9F%E8%92%BB%E9%9B%86/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/01/16/Toming%E7%9A%84%E8%92%9F%E8%92%BB%E9%9B%86/","path":"2025/01/16/Toming的蒟蒻集/","title":"Toming的蒟蒻集"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Toming的蒟蒻集 | TOMING's BLOG</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">

  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
  <script type="text/javascript" src="/js/animefirework.js"></script> 
  <script type="text/javascript" src="/js/fireworks.js"></script>


  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/Thm-V" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TOMING's BLOG</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%9D%82%E9%A1%B9"><span class="nav-text">1.杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%AF%BB%E5%85%A5%E4%BC%98%E5%8C%96"><span class="nav-text">1.1 读入优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F"><span class="nav-text">1.2 链式前向星</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%AF%B9%E6%8B%8D"><span class="nav-text">1.3 对拍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%B8%B8%E7%94%A8STL"><span class="nav-text">2.常用STL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-text">2.1 优先队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-set-multiset"><span class="nav-text">2.2 set&#x2F;multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-map"><span class="nav-text">2.3 map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%95%B0%E5%AD%A6"><span class="nav-text">3.数学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="nav-text">3.1 线性基</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%A4%A7%E5%AD%90%E9%9B%86%E5%BC%82%E6%88%96%E5%92%8C"><span class="nav-text">查询最大子集异或和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E7%AC%ACK%E5%B0%8F%E5%AD%90%E9%9B%86%E5%BC%82%E6%88%96%E5%92%8C"><span class="nav-text">查询第K小子集异或和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="nav-text">合并线性基</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">3.2 位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-GCC%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-text">3.2.1 GCC内建函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E7%B4%A0%E6%95%B0"><span class="nav-text">3.3 素数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E6%AC%A7%E6%8B%89%E7%AD%9B-%E7%BA%BF%E6%80%A7%E7%AD%9B"><span class="nav-text">3.3.1 欧拉筛(线性筛)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">4.数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-ST%E8%A1%A8"><span class="nav-text">4.1 ST表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4-%E6%9C%80%E5%A4%A7%E5%80%BC-%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">用于查询区间 最大值&#x2F;最小值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="nav-text">4.2 树状数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%9B%BE%E8%AE%BA"><span class="nav-text">5.图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Tarjan%E7%AE%97%E6%B3%95"><span class="nav-text">5.1 Tarjan算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E7%BC%A9%E7%82%B9"><span class="nav-text">5.1.1 缩点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E5%89%B2%E8%BE%B9%EF%BC%88%E6%A1%A5%EF%BC%89"><span class="nav-text">5.1.2 割边（桥）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-text">5.2  单源最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-dijkstra%EF%BC%88%E5%A0%86%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-text">5.2.1 dijkstra（堆优化）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">6.字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-text">6.1 字符串哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%95%E5%93%88%E5%B8%8C"><span class="nav-text">6.1.1 字符串单哈希</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8C%E5%93%88%E5%B8%8C"><span class="nav-text">6.1.2 字符串双哈希</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="nav-text">7.计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%89%8D%E7%BD%AE"><span class="nav-text">7.1 前置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E7%82%B9%E4%B8%8E%E7%BA%BF"><span class="nav-text">7.2 点与线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E6%B1%82%E7%82%B9%E5%88%B0%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%8A%95%E5%BD%B1"><span class="nav-text">7.2.1 求点到线上的投影</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E6%B1%82%E4%B8%A4%E7%BA%BF%E7%9A%84%E4%BA%A4%E7%82%B9"><span class="nav-text">7.2.2 求两线的交点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="nav-text">7.3 多边形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF-%E5%8F%89%E7%A7%AF%E6%B3%95"><span class="nav-text">7.3.1 三角形面积(叉积法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%88%E4%B8%8D%E8%AE%BA%E5%87%B8%E5%87%B9%EF%BC%89"><span class="nav-text">7.3.2 多边形面积（不论凸凹）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-Pick%E5%AE%9A%E7%90%86%EF%BC%88%E6%B1%82%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8%E6%A0%BC%E7%82%B9%E6%95%B0%EF%BC%89"><span class="nav-text">7.4  Pick定理（求多边形内部格点数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F"><span class="nav-text">7.5 极角排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-%E5%87%B8%E5%8C%85"><span class="nav-text">7.6 凸包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-1-Graham%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%88%E4%BA%8C%E7%BB%B4%EF%BC%89"><span class="nav-text">7.6.1 Graham扫描法（二维）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-%E6%89%AB%E6%8F%8F%E7%BA%BF"><span class="nav-text">7.7 扫描线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-1-%E6%B1%82%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6"><span class="nav-text">7.7.1 求矩形面积并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-2-%E6%B1%82%E7%9F%A9%E5%BD%A2%E5%91%A8%E9%95%BF"><span class="nav-text">7.7.2 求矩形周长</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3"><span class="nav-text">7.8 旋转卡壳</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-1%E6%B1%82%E5%87%B8%E5%8C%85%E7%9B%B4%E5%BE%84"><span class="nav-text">7.8.1求凸包直径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-2-%E6%B1%82%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="nav-text">7.8.2 求最小矩形覆盖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4"><span class="nav-text">7.9 半平面交</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Toming"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Toming</p>
  <div class="site-description" itemprop="description">循此苦旅，以达繁星</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Thm-V" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Thm-V" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/16/Toming%E7%9A%84%E8%92%9F%E8%92%BB%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TOMING's BLOG">
      <meta itemprop="description" content="循此苦旅，以达繁星">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Toming的蒟蒻集 | TOMING's BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Toming的蒟蒻集
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-16 22:20:55" itemprop="dateCreated datePublished" datetime="2025-01-16T22:20:55+08:00">2025-01-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-18 23:05:31" itemprop="dateModified" datetime="2025-01-18T23:05:31+08:00">2025-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/NOTE/" itemprop="url" rel="index"><span itemprop="name">NOTE</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>存放了一波自己XCPC生涯的板子，会带到比赛场上霍霍的那种，包括遗忘的，新学的。。。</p>
<span id="more"></span>

<h1 id="1-杂项"><a href="#1-杂项" class="headerlink" title="1.杂项"></a>1.杂项</h1><h2 id="1-1-读入优化"><a href="#1-1-读入优化" class="headerlink" title="1.1 读入优化"></a>1.1 读入优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">21</span>,stdin),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">int_Read</span><span class="params">()</span></span>&#123;	<span class="comment">//inline LL LL_Read()</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getc</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">        ch=<span class="built_in">getc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+ch<span class="number">-48</span>;</span><br><span class="line">        ch=<span class="built_in">getc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f?-ret:ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-链式前向星"><a href="#1-2-链式前向星" class="headerlink" title="1.2 链式前向星"></a>1.2 链式前向星</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;	<span class="comment">//n个点m条边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,w,next;</span><br><span class="line">&#125;edge[M];	<span class="comment">//若建图为双向边,边数需*2</span></span><br><span class="line"><span class="type">int</span> head[N],cnt;  <span class="comment">//head数组需初始化为-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		head[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[cnt].to=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=edge[i].next)	<span class="comment">//以此遍历与x相连的边</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-对拍"><a href="#1-3-对拍" class="headerlink" title="1.3 对拍"></a>1.3 对拍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:loop</span><br><span class="line">    read.exe</span><br><span class="line">    my.exe</span><br><span class="line">    std.exe</span><br><span class="line">    fc my.out std.out</span><br><span class="line">    if not errorlevel 1 goto loop</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h1 id="2-常用STL"><a href="#2-常用STL" class="headerlink" title="2.常用STL"></a>2.常用STL</h1><h2 id="2-1-优先队列"><a href="#2-1-优先队列" class="headerlink" title="2.1 优先队列"></a>2.1 优先队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">//大根堆</span></span><br><span class="line">queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q1,q2;  <span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(x);  <span class="comment">//放入元素</span></span><br><span class="line">q.<span class="built_in">pop</span>();    <span class="comment">//弹出堆顶元素</span></span><br><span class="line">q.<span class="built_in">top</span>();    <span class="comment">//返回堆顶元素</span></span><br><span class="line">q.<span class="built_in">empty</span>();  <span class="comment">//判断是否为空,为空时返回值为1</span></span><br><span class="line">q.<span class="built_in">size</span>();   <span class="comment">//返回堆内元素个数</span></span><br><span class="line">q<span class="number">1.</span><span class="built_in">swap</span>(q2);	<span class="comment">//交换两个堆</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-set-multiset"><a href="#2-2-set-multiset" class="headerlink" title="2.2 set&#x2F;multiset"></a>2.2 set&#x2F;multiset</h2><p>​	set 是 C++ 标准库中的一个容器，属于关联容器的一种。它是一个有序集合，其中的元素是唯一的，即每个元素只能在集合中出现一次。set 是基于红黑树实现的，这使得插入、删除和查找操作的时间复杂度都是 O(log n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s,s2;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(x);    <span class="comment">//在set集合中插入x</span></span><br><span class="line">s.<span class="built_in">erase</span>(x); <span class="comment">//在set集合中删除指定值x</span></span><br><span class="line">s.<span class="built_in">erase</span>(迭代器);    <span class="comment">//通过迭代器删除元素</span></span><br><span class="line">s.<span class="built_in">clear</span>();  <span class="comment">//清空set集合中的所有值</span></span><br><span class="line">s.<span class="built_in">empty</span>();  <span class="comment">//判断set集合是否为空,为空时返回1</span></span><br><span class="line">s.<span class="built_in">size</span>();   <span class="comment">//返回set集合中元素的长度</span></span><br><span class="line">s.<span class="built_in">count</span>(x); <span class="comment">//返回set集合中x元素的个数（set中没有重复元素，所以返回值只能为1或0）</span></span><br><span class="line">s.<span class="built_in">lower_bound</span>(x);   <span class="comment">//返回第一个大于等于x的值</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>(y);   <span class="comment">//返回最后一个大于等于x的值</span></span><br><span class="line">s.<span class="built_in">swap</span>(s2); <span class="comment">//交换两个set集合</span></span><br><span class="line"></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; s; <span class="comment">//简单理解为可以插入重复元素的set,因此multiset在使用count时返回值不一定只为0或1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-map"><a href="#2-3-map" class="headerlink" title="2.3 map"></a>2.3 map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; m;	<span class="comment">//typename1是键的类型,typename2是值的类型</span></span><br><span class="line">m[key]=value;	<span class="comment">//在map中插入（key:value）（通过访问m[key]来访问对应的value）</span></span><br><span class="line">迭代器-&gt;first;	<span class="comment">//访问键</span></span><br><span class="line">迭代器-&gt;second;	<span class="comment">//访问值</span></span><br><span class="line">m.<span class="built_in">find</span>(key);	<span class="comment">//返回键为key映射的迭代器</span></span><br><span class="line">m.<span class="built_in">erase</span>(迭代器);	<span class="comment">//通过迭代器删除map中的元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(key);	<span class="comment">//删除map中键为key的元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(迭代器<span class="number">1</span>,迭代器<span class="number">2</span>);	<span class="comment">//删除迭代器1和迭代器2之间的所有元素,左开右闭</span></span><br><span class="line">m.<span class="built_in">size</span>();	<span class="comment">//返回map中映射的对数</span></span><br><span class="line">m.<span class="built_in">clear</span>();	<span class="comment">//清空map中的所有元素</span></span><br><span class="line">m.<span class="built_in">empty</span>();	<span class="comment">//判断map是否为空,为空时返回1</span></span><br><span class="line">m.<span class="built_in">swap</span>(m2);	<span class="comment">//交换两个map</span></span><br></pre></td></tr></table></figure>



<h1 id="3-数学"><a href="#3-数学" class="headerlink" title="3.数学"></a>3.数学</h1><h2 id="3-1-线性基"><a href="#3-1-线性基" class="headerlink" title="3.1 线性基"></a>3.1 线性基</h2><ul>
<li><h3 id="查询最大子集异或和"><a href="#查询最大子集异或和" class="headerlink" title="查询最大子集异或和"></a>查询最大子集异或和</h3></li>
<li><h3 id="查询第K小子集异或和"><a href="#查询第K小子集异或和" class="headerlink" title="查询第K小子集异或和"></a>查询第K小子集异或和</h3></li>
<li><h3 id="合并线性基"><a href="#合并线性基" class="headerlink" title="合并线性基"></a>合并线性基</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lg2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">31</span>^__builtin_clz(x); <span class="comment">// 63^__builtin_clzll(x)用于处理LL类型的x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="type">int</span> CNT=<span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> Zero=<span class="literal">false</span>;</span><br><span class="line">	LL B[BN];</span><br><span class="line">	<span class="built_in">Base</span>()&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BN;i++)</span><br><span class="line">			B[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向线性基中插入元素</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Ins</span><span class="params">(LL x)</span></span>&#123;	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">lg2</span>(x);~i;i=<span class="built_in">lg2</span>(x))</span><br><span class="line">				<span class="keyword">if</span>(B[i])</span><br><span class="line">					x^=B[i];</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					B[i]=x;</span><br><span class="line">					<span class="keyword">return</span>;	<span class="comment">//插入成功</span></span><br><span class="line">				&#125;</span><br><span class="line">		Zero=<span class="literal">true</span>;	<span class="comment">//x能被线性基中的数表示,标记特殊情况0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询线性基中异或最大值</span></span><br><span class="line">	<span class="function">LL <span class="title">Query_Max</span><span class="params">()</span></span>&#123;	</span><br><span class="line">		LL ANS=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=BN<span class="number">-1</span>;~i;i--)</span><br><span class="line">			ANS=<span class="built_in">max</span>(ANS,ANS^B[i]);</span><br><span class="line">		<span class="keyword">return</span> ANS;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询线性基第K小异或值(重建)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Rebulid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BN;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">				<span class="keyword">if</span>(B[i]&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">					B[i]^=B[j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BN;i++)</span><br><span class="line">			<span class="keyword">if</span>(B[i])</span><br><span class="line">				B[CNT++]=B[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询线性基第K小异或值(查询)</span></span><br><span class="line">	<span class="function">LL <span class="title">Query_MinK</span><span class="params">(LL k)</span></span>&#123;</span><br><span class="line">		LL ANS=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(Zero)	</span><br><span class="line">			k--;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1ll</span>&lt;&lt;CNT&lt;k<span class="number">+1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;CNT;i++)</span><br><span class="line">			<span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">				ANS^=B[i];</span><br><span class="line">		<span class="keyword">return</span> ANS;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//线性基合并</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(Base &amp;BB)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BN;i++)</span><br><span class="line">			<span class="keyword">if</span>(BB.B[i])</span><br><span class="line">				<span class="built_in">Ins</span>(BB.B[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-位运算"><a href="#3-2-位运算" class="headerlink" title="3.2 位运算"></a>3.2 位运算</h2><h3 id="3-2-1-GCC内建函数"><a href="#3-2-1-GCC内建函数" class="headerlink" title="3.2.1 GCC内建函数"></a>3.2.1 GCC内建函数</h3><ul>
<li><code>int __builtin_clz(unsigned int x)</code>：返回x的二进制的前置零的个数。当x为0时，结果未定义。</li>
<li><code>int __builtin_ctz(unsigned int x)</code>：返回x的二进制末尾连续0的个数。当x为0时，结果未定义。</li>
<li><code>int __builtin_ffs(int x)</code>：返回x的二进制末尾最后一个1的位置，最低位编号为1，当x为时返回0。</li>
<li><code>int __builtin_popcount(unsigned int x)</code>：返回x的二进制中1的个数。<br>以上各函数都可以在函数名末尾添加ll（如<code>__builtin_clzll</code>），使参数类型变为<code>(undigned) long long</code>（返回值仍然是<code>int</code>类型）</li>
</ul>
<h2 id="3-3-素数"><a href="#3-3-素数" class="headerlink" title="3.3 素数"></a>3.3 素数</h2><h3 id="3-3-1-欧拉筛-线性筛"><a href="#3-3-1-欧拉筛-线性筛" class="headerlink" title="3.3.1 欧拉筛(线性筛)"></a>3.3.1 欧拉筛(线性筛)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> tot;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime[N];</span><br><span class="line"><span class="type">bool</span> is_not_pr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=MAX_NUM;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_not_pr[i])&#123;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">             tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(usigned j=<span class="number">0</span>;j&lt;tot &amp;&amp; i*prime[j]&lt;=MAX_NUM;j++)&#123;</span><br><span class="line">            is_not_pr[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4.数据结构"></a>4.数据结构</h1><h2 id="4-1-ST表"><a href="#4-1-ST表" class="headerlink" title="4.1 ST表"></a>4.1 ST表</h2><ul>
<li><h3 id="用于查询区间-最大值-最小值"><a href="#用于查询区间-最大值-最小值" class="headerlink" title="用于查询区间 最大值&#x2F;最小值"></a>用于查询区间 最大值&#x2F;最小值</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stmax[N][stN];  <span class="comment">//以取区间最大值为例</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lg2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">31</span>^__builtin_clz(x); <span class="comment">// 63^__builtin_clzll(x)用于处理LL类型的x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">st_Build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		stmax[i][<span class="number">0</span>]=<span class="built_in">int_Read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">			stmax[i][j]=<span class="built_in">max</span>(stmax[i][j<span class="number">-1</span>],stmax[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">st_query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> wz=<span class="built_in">lg2</span>(R-L<span class="number">+1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(stmax[L][wz],stmax[R-(<span class="number">1</span>&lt;&lt;wz)<span class="number">+1</span>][wz]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-树状数组"><a href="#4-2-树状数组" class="headerlink" title="4.2 树状数组"></a>4.2 树状数组</h2><h1 id="5-图论"><a href="#5-图论" class="headerlink" title="5.图论"></a>5.图论</h1><h2 id="5-1-Tarjan算法"><a href="#5-1-Tarjan算法" class="headerlink" title="5.1 Tarjan算法"></a>5.1 Tarjan算法</h2><h3 id="5-1-1-缩点"><a href="#5-1-1-缩点" class="headerlink" title="5.1.1 缩点"></a>5.1.1 缩点</h3><p>​	将<strong>有向图</strong>中的强连通分量缩成一个点，此操作即为缩点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfn[N],low[N],tnt;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> Stack[N],t;</span><br><span class="line"><span class="type">int</span> col[N],Val[N],num; <span class="comment">//染色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tnt;</span><br><span class="line">	vis[x]=<span class="literal">true</span>;</span><br><span class="line">	Stack[++t]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=Head[x];~i;i=edge[i].Next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[edge[i].to])&#123;</span><br><span class="line">			<span class="built_in">Tarjan</span>(edge[i].to);</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[x],low[edge[i].to]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vis[edge[i].to])</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[x],dfn[edge[i].to]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">		num++;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			col[Stack[t]]=num;</span><br><span class="line">			Val[num]+=w[Stack[t]];</span><br><span class="line">			vis[Stack[t]]=<span class="literal">false</span>;</span><br><span class="line">		&#125;<span class="keyword">while</span>(Stack[t--]!=x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-割边（桥）"><a href="#5-1-2-割边（桥）" class="headerlink" title="5.1.2 割边（桥）"></a>5.1.2 割边（桥）</h3><p>​	如果删除<strong>无向图</strong>中的某条边会使无向图的连通分量数增多，则把这条边称为割边或桥。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfn[N],low[N],tnt;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> Stack[N],t;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;Bridge[M];</span><br><span class="line"><span class="type">int</span> Bt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tnt;</span><br><span class="line">	vis[x]=<span class="literal">true</span>;</span><br><span class="line">	Stack[++t]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=Head[x];~i;i=edge[i].Next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[edge[i].to])&#123;</span><br><span class="line">			<span class="built_in">Tarjan</span>(edge[i].to);</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[x],low[edge[i].to]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vis[edge[i].to])</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[x],dfn[edge[i].to]);</span><br><span class="line">		<span class="keyword">if</span>(dfn[x]&lt;low[edge[i].to])</span><br><span class="line">			Bridge[++Bt]=<span class="built_in">make_pair</span>(x,edge[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			vis[Stack[t]]=<span class="literal">false</span>;</span><br><span class="line">		&#125;<span class="keyword">while</span>(Stack[t--]!=x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-单源最短路"><a href="#5-2-单源最短路" class="headerlink" title="5.2  单源最短路"></a>5.2  单源最短路</h2><h3 id="5-2-1-dijkstra（堆优化）"><a href="#5-2-1-dijkstra（堆优化）" class="headerlink" title="5.2.1 dijkstra（堆优化）"></a>5.2.1 dijkstra（堆优化）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,s;  <span class="comment">//结点数 边数 源</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line">LL dis[MAXN];                                                           </span><br><span class="line">priority_queue&lt;pair&lt;LL,<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        vis[i]=<span class="literal">false</span>,dis[i]=<span class="number">-1</span>;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[s];~i;i=edge[i].to)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-edge[i].w,edge[i].v));</span><br><span class="line">        <span class="keyword">if</span>(dis[edge[i].v]==<span class="number">-1</span>)</span><br><span class="line">            dis[edge[i].v]=edge[i].w;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dis[edge[i].v]=<span class="built_in">min</span>(dis[edge[i].v],edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];~i;i=edge[i].to)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].v]&gt;dis[x]+edge[i].w || dis[edge[i].v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dis[edge[i].v]=dis[x]+edge[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[edge[i].v],edge[i].v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h1><h2 id="6-1-字符串哈希"><a href="#6-1-字符串哈希" class="headerlink" title="6.1 字符串哈希"></a>6.1 字符串哈希</h2><h3 id="6-1-1-字符串单哈希"><a href="#6-1-1-字符串单哈希" class="headerlink" title="6.1.1 字符串单哈希"></a>6.1.1 字符串单哈希</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ull <span class="title">Hash</span><span class="params">(ull B,ull Modp,<span class="type">char</span> s[])</span></span>&#123;  <span class="comment">//此处B和Modp应该尽量大</span></span><br><span class="line">    ull H=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">strlen</span>(s<span class="number">+1</span>);i++)</span><br><span class="line">        H=((H*B)%Modp+s[i])%Modp;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-2-字符串双哈希"><a href="#6-1-2-字符串双哈希" class="headerlink" title="6.1.2 字符串双哈希"></a>6.1.2 字符串双哈希</h3><p>​	和字符串单哈希类似，只是用不同的进制数和模数分别计算两次，得到该字符串的两个哈希值，用这两个哈希值来确定唯一一个字符串。</p>
<h1 id="7-计算几何"><a href="#7-计算几何" class="headerlink" title="7.计算几何"></a>7.计算几何</h1><p>​	在做或者调试过程中，请先检查一遍所有相关变量的类型，以及各种相关函数的返回类型。（血泪教训QAQ）</p>
<h2 id="7-1-前置"><a href="#7-1-前置" class="headerlink" title="7.1 前置"></a>7.1 前置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用double类型时记得处理精度问题</span></span><br><span class="line"><span class="comment">//浮点比较大小的时候请采用sgn()方式进行比较</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">POINT</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">inline</span> POINT <span class="keyword">operator</span> +(<span class="type">const</span> POINT &amp;p)&#123;</span><br><span class="line">        <span class="keyword">return</span> POINT&#123;x+p.x,y+p.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> POINT <span class="keyword">operator</span> -(<span class="type">const</span> POINT &amp;p)&#123;</span><br><span class="line">        <span class="keyword">return</span> POINT&#123;x-p.x,y-p.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> POINT <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">int</span> k)&#123;	<span class="comment">//数乘</span></span><br><span class="line">		<span class="keyword">return</span> POINT&#123;x*k,y*k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> <span class="keyword">operator</span> ^(<span class="type">const</span> POINT &amp;p)&#123;  <span class="comment">//点乘  //^优先级小于比较符号，使用时记得加括号</span></span><br><span class="line">        <span class="keyword">return</span> x*p.y+y*p.x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> <span class="keyword">operator</span> *(<span class="type">const</span> POINT &amp;p)&#123;  <span class="comment">//叉乘</span></span><br><span class="line">        <span class="keyword">return</span> x*p.y-y*p.x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> POINT &amp;p)&#123;</span><br><span class="line">        <span class="keyword">return</span> x==p.x &amp;&amp; y==p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> POINT &amp;p)&#123;</span><br><span class="line">        <span class="keyword">return</span> !(POINT&#123;x,y&#125;==p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">len_square</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*x+y*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LINE</span>&#123;</span><br><span class="line">    POINT be,en;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">angle</span><span class="params">()</span></span>&#123;	<span class="comment">//可能会被卡精度</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">atan2</span>((en-be).y,(en-be).x);	<span class="comment">//返回角度范围(-pi,pi]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-2-点与线"><a href="#7-2-点与线" class="headerlink" title="7.2 点与线"></a>7.2 点与线</h2><h3 id="7-2-1-求点到线上的投影"><a href="#7-2-1-求点到线上的投影" class="headerlink" title="7.2.1 求点到线上的投影"></a>7.2.1 求点到线上的投影</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POINT中需要配置&#x27;+&#x27;,&#x27;-&#x27;,&#x27;数乘*&#x27;,&#x27;点乘^&#x27;</span></span><br><span class="line"><span class="function">POINT <span class="title">Get_line_projection</span><span class="params">(POINT p0,POINT p1,POINT p2)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> k=((p2-p1)^(p0-p1))/((p2-p1)^(p2-p1));</span><br><span class="line">    <span class="keyword">return</span> p1+(p2-p1)*k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-求两线的交点"><a href="#7-2-2-求两线的交点" class="headerlink" title="7.2.2 求两线的交点"></a>7.2.2 求两线的交点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POINT中需配置&#x27;-&#x27;,&#x27;数乘*&#x27;,&#x27;叉乘*&#x27;</span></span><br><span class="line"><span class="function">POINT <span class="title">Get_line_intersection</span><span class="params">(LINE l1, LINE l2)</span> </span>&#123;</span><br><span class="line">    POINT vect1=l<span class="number">1.</span>en-l<span class="number">1.</span>be,vect2=l<span class="number">2.</span>en-l<span class="number">2.</span>be;</span><br><span class="line">	<span class="type">double</span> t=(l<span class="number">1.</span>be-l<span class="number">2.</span>be)*vect2/(vect2*vect1);</span><br><span class="line">	<span class="keyword">return</span> l<span class="number">1.</span>be+vect1*t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-3-多边形"><a href="#7-3-多边形" class="headerlink" title="7.3 多边形"></a>7.3 多边形</h2><h3 id="7-3-1-三角形面积-叉积法"><a href="#7-3-1-三角形面积-叉积法" class="headerlink" title="7.3.1 三角形面积(叉积法)"></a>7.3.1 三角形面积(叉积法)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Triangle_area_cross</span><span class="params">(POINT p1,POINT p2,POINT p0)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">double</span>(<span class="built_in">abs</span>((p1-p0)*(p2-p0)))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-2-多边形面积（不论凸凹）"><a href="#7-3-2-多边形面积（不论凸凹）" class="headerlink" title="7.3.2 多边形面积（不论凸凹）"></a>7.3.2 多边形面积（不论凸凹）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POINT point[N];  <span class="comment">//多边形上的点按照逆时针排序</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Polygonal_area</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        ans+=<span class="built_in">double</span>((point[i]-point[<span class="number">1</span>])*(point[i<span class="number">+1</span>]-point[<span class="number">1</span>]));  <span class="comment">//将多边形切割成多个三角形</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(ans/<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-Pick定理（求多边形内部格点数）"><a href="#7-4-Pick定理（求多边形内部格点数）" class="headerlink" title="7.4  Pick定理（求多边形内部格点数）"></a>7.4  Pick定理（求多边形内部格点数）</h2><p>​	给定顶点均为整点的简单多边形，其面积为$S$，内部格点数为$a$，边上格点数目为$b$。Pick定理给定它们之间的关系为$S&#x3D;a+\frac{b}{2}-1$，常用来求内部格点数，变形为$a&#x3D;S-\frac{b}{2}+1$。</p>
<h2 id="7-5-极角排序"><a href="#7-5-极角排序" class="headerlink" title="7.5 极角排序"></a>7.5 极角排序</h2><p>​	在struct POINT中插入如下代码段，后面即可用sort等进行排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">quadrant</span><span class="params">(POINT p)</span></span>&#123;  <span class="comment">//判断象限</span></span><br><span class="line">    <span class="keyword">if</span>(p.x&gt;<span class="number">0</span> &amp;&amp; p.y&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.x&lt;=<span class="number">0</span> &amp;&amp; p.y&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.x&lt;<span class="number">0</span> &amp;&amp; p.y&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.x&gt;=<span class="number">0</span> &amp;&amp; p.y&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//表示在原点上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> POINT &amp;p)&#123;  <span class="comment">//从x正半轴开始逆时针排序</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">quadrant</span>(POINT&#123;x,y&#125;)==<span class="built_in">quadrant</span>(p))  <span class="comment">//先判断象限</span></span><br><span class="line">        <span class="keyword">return</span> POINT&#123;x,y&#125;*p&gt;<span class="number">0</span>;  <span class="comment">//同一象限内通过判断叉积正负来判断相对大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quadrant</span>(POINT&#123;x,y&#125;)&lt;<span class="built_in">quadrant</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一般的</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> POINT &amp;p)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">quadrant</span>(POINT&#123;x,y&#125;)!=<span class="built_in">quadrant</span>(p))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> POINT&#123;x,y&#125;*p==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-凸包"><a href="#7-6-凸包" class="headerlink" title="7.6 凸包"></a>7.6 凸包</h2><h3 id="7-6-1-Graham扫描法（二维）"><a href="#7-6-1-Graham扫描法（二维）" class="headerlink" title="7.6.1 Graham扫描法（二维）"></a>7.6.1 Graham扫描法（二维）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POINT中需要配置&#x27;-&#x27;，&#x27;*&#x27;，&#x27;.len()&#x27;</span></span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">POINT q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(POINT p1,POINT p2)</span></span>&#123;</span><br><span class="line">    p1=p1-point[<span class="number">1</span>];</span><br><span class="line">    p2=p2-point[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(p1*p2==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> p<span class="number">1.l</span>en()&lt;p<span class="number">2.l</span>en();</span><br><span class="line">    <span class="keyword">return</span> p1*p2&gt;<span class="number">0</span>; <span class="comment">//叉乘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graham_scan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(point[<span class="number">1</span>].x&gt;point[i].x || (point[<span class="number">1</span>].x==point[i].x &amp;&amp; point[<span class="number">1</span>].y&gt;point[i].y))</span><br><span class="line">            <span class="built_in">swap</span>(point[<span class="number">1</span>],point[i]);</span><br><span class="line">   	<span class="built_in">sort</span>(point<span class="number">+2</span>,point<span class="number">+1</span>+n,cmp);  <span class="comment">//以左下角的点为基准点进行极角排序</span></span><br><span class="line">    q[++top]=point[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((q[top]-q[top<span class="number">-1</span>])*(point[i]-q[top])&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                top--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q[++top]=point[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-7-扫描线"><a href="#7-7-扫描线" class="headerlink" title="7.7 扫描线"></a>7.7 扫描线</h2><h3 id="7-7-1-求矩形面积并"><a href="#7-7-1-求矩形面积并" class="headerlink" title="7.7.1 求矩形面积并"></a>7.7.1 求矩形面积并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;	<span class="comment">//矩形数量</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> leny;</span><br><span class="line"><span class="type">int</span> Y[<span class="number">2</span>*N];  <span class="comment">//所有出现的y值，用于离散化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SCANLINE</span>&#123;  <span class="comment">//垂直于x轴</span></span><br><span class="line">    <span class="type">int</span> bey;</span><br><span class="line">    <span class="type">int</span> eny;  <span class="comment">//bey&lt;=eny</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> type;  <span class="comment">// 1——进边 -1——出边</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> SCANLINE &amp;scanline1)&#123;</span><br><span class="line">        <span class="keyword">return</span> x==scanline<span class="number">1.</span>x ? type&gt;scanline<span class="number">1.</span>type : x&lt;scanline<span class="number">1.</span>x;  <span class="comment">//在求矩形面积并时type先后没影响，但在求矩形周长时先加后减很重要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;scanline[<span class="number">2</span>*N];	<span class="comment">//图中每条竖直线的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TREE</span>&#123;	<span class="comment">//把每一个小区间看作一个结点</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="type">int</span> len;	<span class="comment">//真实长度</span></span><br><span class="line">	<span class="type">int</span> num;	<span class="comment">//整个区间覆盖次数</span></span><br><span class="line">&#125;tree[<span class="number">2</span>*<span class="number">8</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	tree[k].l=L;</span><br><span class="line">	tree[k].r=R;</span><br><span class="line">	tree[k].len=tree[k].num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L==R)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> Mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">Build</span>(L,Mid,k*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">Build</span>(Mid<span class="number">+1</span>,R,k*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;  <span class="comment">//虽是区间加，但无需lazy_tag，因为有进边就有出边，且当父亲被全覆盖时便和儿子没有关系</span></span><br><span class="line">	<span class="keyword">if</span>(tree[k].num)</span><br><span class="line">		tree[k].len=Y[tree[k].r<span class="number">+1</span>]-Y[tree[k].l];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tree[k].len=tree[k*<span class="number">2</span>].len+tree[k*<span class="number">2</span><span class="number">+1</span>].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> aiml,<span class="type">int</span> aimr,<span class="type">int</span> val,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> k)</span></span>&#123;	<span class="comment">//aiml和aimr代表真实纵坐标值</span></span><br><span class="line">	<span class="keyword">if</span>(aiml&lt;=Y[L] &amp;&amp; Y[R<span class="number">+1</span>]&lt;=aimr)&#123;</span><br><span class="line">		tree[k].num+=val;</span><br><span class="line">		<span class="built_in">pushup</span>(k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(aiml&lt;=Y[Mid])	</span><br><span class="line">		<span class="built_in">Update</span>(aiml,aimr,val,L,Mid,k*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(Y[Mid<span class="number">+1</span>]&lt;aimr)</span><br><span class="line">		<span class="built_in">Update</span>(aiml,aimr,val,Mid<span class="number">+1</span>,R,k*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">ScanLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i64 ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先处理scanline和Y</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//纵坐标离散处理</span></span><br><span class="line">	<span class="built_in">sort</span>(Y<span class="number">+1</span>,Y<span class="number">+1</span><span class="number">+2</span>*n);</span><br><span class="line">	leny=<span class="built_in">unique</span>(Y<span class="number">+1</span>,Y<span class="number">+1</span><span class="number">+2</span>*n)-(Y<span class="number">+1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Build</span>(<span class="number">1</span>,leny<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(scanline<span class="number">+1</span>,scanline<span class="number">+1</span><span class="number">+2</span>*n);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*n;i++)&#123;	<span class="comment">//根据是否需要考虑最后一条边灵活确定是否需要取到等号</span></span><br><span class="line">		<span class="built_in">Update</span>(scanline[i].bey,scanline[i].eny,scanline[i].type,<span class="number">1</span>,leny<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">		ans=ans<span class="number">+1ll</span>*(scanline[i<span class="number">+1</span>].x-scanline[i].x)*tree[<span class="number">1</span>].len;	<span class="comment">//如果for里取等号，需处理i+1非法访问的问题</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-7-2-求矩形周长"><a href="#7-7-2-求矩形周长" class="headerlink" title="7.7.2 求矩形周长"></a>7.7.2 求矩形周长</h3><p>​	和求矩形面积并类似，只不过需要分别沿竖直和水平方向各扫描一遍，即只要重写scanline和Y即可。同时，将答案统计一行更改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans=ans+<span class="built_in">abs</span>(tree[<span class="number">1</span>].len-last);</span><br><span class="line">last=tree[<span class="number">1</span>].len;	<span class="comment">//last定义在循环外面</span></span><br></pre></td></tr></table></figure>

<h2 id="7-8-旋转卡壳"><a href="#7-8-旋转卡壳" class="headerlink" title="7.8 旋转卡壳"></a>7.8 旋转卡壳</h2><p>​	在凸包算法的基础上，通过枚举凸包上某一条边的同时维护其他需要的点，能够在线性时间内求解如凸包直径、最小矩形覆盖等和凸包性质相关的问题。</p>
<h3 id="7-8-1求凸包直径"><a href="#7-8-1求凸包直径" class="headerlink" title="7.8.1求凸包直径"></a>7.8.1求凸包直径</h3><p>​	首先使用任何一种凸包算法求出给定所有点的凸包，有着最长距离的点对一定在凸包上。而由于凸包的形状，我们发现，逆时针地遍历凸包上的边，对于每条边都找到离这条边最远的点，那么这时随着边的转动，对应的最远点也在逆时针旋转，不会有反向的情况，这意味着我们可以在逆时针枚举凸包上的边时，记录并维护一个当前最远点，并不断计算、更新答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POINT中需要配置&#x27;-&#x27;，&#x27;叉乘*&#x27;，&#x27;.len()&#x27;，&#x27;len_square()&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Graham扫描线求凸包</span></span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">POINT q[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(POINT p1,POINT p2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graham_scan</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Triangle_area_cross_2</span><span class="params">(POINT p1,POINT p2,POINT p0)</span></span>&#123;	<span class="comment">//注意数据类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>((p1-p0)*(p2-p0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">diameter</span><span class="params">()</span></span>&#123;  <span class="comment">//注意数据类型</span></span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">2</span>)&#123; </span><br><span class="line">    	<span class="keyword">return</span> (q[<span class="number">1</span>]-q[<span class="number">2</span>]).<span class="built_in">len_square</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q[top<span class="number">+1</span>]=q[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">3</span>;	</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">Triangle_area_cross_2</span>(q[i],q[i<span class="number">+1</span>],q[idx])&lt;=<span class="built_in">Triangle_area_cross_2</span>(q[i],q[i<span class="number">+1</span>],q[idx%top<span class="number">+1</span>]))</span><br><span class="line">            idx=idx%top<span class="number">+1</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>((q[idx]-q[i]).<span class="built_in">len_square</span>(),(q[idx]-q[i<span class="number">+1</span>]).<span class="built_in">len_square</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-8-2-求最小矩形覆盖"><a href="#7-8-2-求最小矩形覆盖" class="headerlink" title="7.8.2 求最小矩形覆盖"></a>7.8.2 求最小矩形覆盖</h3><p>​	跟求凸包直径类似，对于每条边都找到离这条边最远的点，我们还需要确定矩形的左右边界。所以这次我们需要维护三个点：一个在所枚举的直线对面的点、两个在不同侧面的点。对面的最优点仍然是用叉积算面积来比较，此时比较面积就是在比较这个矩形的一个边长。侧面的最优点则是用点积来比较，因为比较点积就是比较投影的长度，左右两个投影长度相加可以代表这个矩形的另一个边长。这两个边长的最优性相互独立，因此找到三个最优点的位置就能够确定以当前边所在直线为矩阵的一条边时，能覆盖所有点的矩形最小面积。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POINT中需要配置&#x27;+&#x27;,&#x27;-&#x27;，&#x27;数乘*&#x27;,&#x27;点乘^&#x27;,&#x27;叉乘*&#x27;，&#x27;.len()&#x27;，&#x27;len_square()&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//精度判断</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点到线上的投影</span></span><br><span class="line"><span class="function">POINT <span class="title">Get_line_projection</span><span class="params">(POINT p0,POINT p1,POINT p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Graham扫描线求凸包</span></span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">POINT q[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(POINT p1,POINT p2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graham_scan</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Triangle_area_cross_2</span><span class="params">(POINT p1,POINT p2,POINT p0)</span></span>&#123;	<span class="comment">//注意数据类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>((p1-p0)*(p2-p0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> ans=<span class="number">-1</span>;</span><br><span class="line">POINT pld,prd,pru,plu;	<span class="comment">//答案矩形的四个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Min_rect_cover</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q[top<span class="number">+1</span>]=q[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> idxl=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> idxr=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">sgn</span>(<span class="built_in">Triangle_area_cross_2</span>(q[i],q[i<span class="number">+1</span>],q[idx])-<span class="built_in">Triangle_area_cross_2</span>(q[i],q[i<span class="number">+1</span>],q[idx%top<span class="number">+1</span>]))&lt;=<span class="number">0</span>)</span><br><span class="line">            idx=idx%top<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">sgn</span>(((q[i<span class="number">+1</span>]-q[i])^(q[idxr]-q[i]))-((q[i<span class="number">+1</span>]-q[i])^(q[idxr%top<span class="number">+1</span>]-q[i])))&lt;=<span class="number">0</span>)</span><br><span class="line">            idxr=idxr%top<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">            idxl=idxr;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">sgn</span>(((q[i]-q[i<span class="number">+1</span>])^(q[idxl]-q[i<span class="number">+1</span>]))-((q[i]-q[i<span class="number">+1</span>])^(q[idxl%top<span class="number">+1</span>]-q[i<span class="number">+1</span>])))&lt;=<span class="number">0</span>)</span><br><span class="line">            idxl=idxl%top<span class="number">+1</span>;</span><br><span class="line">        <span class="type">double</span> t1=<span class="built_in">Triangle_area_cross_2</span>(q[i],q[i<span class="number">+1</span>],q[idx]);</span><br><span class="line">        <span class="type">double</span> t2=(<span class="built_in">fabs</span>((q[i]-q[i<span class="number">+1</span>])^(q[idxl]-q[i<span class="number">+1</span>]))+<span class="built_in">fabs</span>((q[i<span class="number">+1</span>]-q[i])^(q[idxr]-q[i]))-<span class="built_in">fabs</span>((q[i]-q[i<span class="number">+1</span>])^(q[i]-q[i<span class="number">+1</span>])));</span><br><span class="line">        <span class="type">double</span> t3=<span class="built_in">fabs</span>((q[i]-q[i<span class="number">+1</span>])^(q[i]-q[i<span class="number">+1</span>]));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(ans-t1*t2/t3)&gt;=<span class="number">0</span> || ans&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans=t1*t2/t3;</span><br><span class="line">            pld=<span class="built_in">Get_line_projection</span>(q[idxl],q[i],q[i<span class="number">+1</span>]);</span><br><span class="line">            prd=<span class="built_in">Get_line_projection</span>(q[idxr],q[i],q[i<span class="number">+1</span>]);</span><br><span class="line">            plu=<span class="built_in">Get_line_projection</span>(q[idxl],q[idx],q[idx]+(q[i]-q[i<span class="number">+1</span>]));</span><br><span class="line">            pru=<span class="built_in">Get_line_projection</span>(q[idxr],q[idx],q[idx]+(q[i]-q[i<span class="number">+1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-9-半平面交"><a href="#7-9-半平面交" class="headerlink" title="7.9 半平面交"></a>7.9 半平面交</h2><p>​	可以理解为向量集中每一个向量的左&#x2F;右侧的交，或者是形如下面方程组的解。</p>
<p>$$<br>f(i) &#x3D;<br>\begin{cases}<br>A_1 x + B_1 y + C_1 \leq 0, \\<br>A_2 x + B_2 y + C_2 \leq 0, \\<br>…<br>\end{cases}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> linenum;</span><br><span class="line">LINE line[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,w;</span><br><span class="line">LINE q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Polygonal_area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">POINT <span class="title">Get_line_intersection</span><span class="params">(LINE l1, LINE l2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">On_the_right_side</span><span class="params">(POINT p,LINE l)</span></span>&#123;	<span class="comment">//判断点p是否在有向线l的右侧</span></span><br><span class="line">	<span class="keyword">return</span>  <span class="built_in">sgn</span>((l.en-l.be)*(p-l.be))&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(LINE l1,LINE l2)</span></span>&#123;	<span class="comment">//极角+左侧排序</span></span><br><span class="line">	<span class="type">double</span> A=l<span class="number">1.</span><span class="built_in">angle</span>();</span><br><span class="line">	<span class="type">double</span> B=l<span class="number">2.</span><span class="built_in">angle</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sgn</span>(A-B)==<span class="number">0</span> ? <span class="built_in">On_the_right_side</span>(l<span class="number">2.</span>be,l1) : <span class="built_in">sgn</span>(A-B)&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Half_plane</span><span class="params">()</span></span>&#123;	<span class="comment">//求解一系列给定有向线段左侧平面的交</span></span><br><span class="line">	<span class="built_in">sort</span>(line<span class="number">+1</span>,line<span class="number">+1</span>+linenum,cmp);</span><br><span class="line">	t=w=<span class="number">1</span>;</span><br><span class="line">	q[<span class="number">1</span>]=line[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=linenum;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(line[i].<span class="built_in">angle</span>()-line[i<span class="number">-1</span>].<span class="built_in">angle</span>())==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(t&lt;w &amp;&amp; <span class="built_in">On_the_right_side</span>(<span class="built_in">Get_line_intersection</span>(q[w],q[w<span class="number">-1</span>]),line[i]))	<span class="comment">//先删队头</span></span><br><span class="line">			w--;</span><br><span class="line">		<span class="keyword">while</span>(t&lt;w &amp;&amp; <span class="built_in">On_the_right_side</span>(<span class="built_in">Get_line_intersection</span>(q[t],q[t<span class="number">+1</span>]),line[i]))	<span class="comment">//后删队尾</span></span><br><span class="line">			t++;</span><br><span class="line">		q[++w]=line[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t&lt;w &amp;&amp; <span class="built_in">On_the_right_side</span>(<span class="built_in">Get_line_intersection</span>(q[w],q[w<span class="number">-1</span>]),q[t])) <span class="comment">//去掉多余的头</span></span><br><span class="line">		w--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/XCPC-ACM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa-solid fa-tag"></i> XCPC/ACM - 学习笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/01/16/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/" rel="prev" title="测试文章">
                  <i class="fa fa-angle-left"></i> 测试文章
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/01/18/Hexo+Next%20%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E9%9B%86/" rel="next" title="Hexo+Next 小白搭建简易博客问题集">
                  Hexo+Next 小白搭建简易博客问题集 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Toming</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">18k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16 分钟</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--隐藏网页底部的power by-->
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->



    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
